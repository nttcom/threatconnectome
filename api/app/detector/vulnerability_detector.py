from datetime import datetime

from sqlalchemy.orm import Session

from app import command, models, persistence
from app.business.ticket_business import create_ticket_internal
from app.detector.version import (
    PackageFamily,
    VulnerableRange,
    gen_version_instance,
)


def fix_threats_for_topic(db: Session, topic: models.Topic) -> list[str]:
    now = datetime.now()

    # remove threats which lost related dependency -- for the case Topic.tags updated
    valid_dependency_ids = {dependency.dependency_id for dependency in topic.dependencies_via_tag}
    for threat in topic.threats:
        if threat.dependency_id not in valid_dependency_ids:
            persistence.delete_threat(db, threat)

    # collect VulnerableRanges for each tags from TopicAction
    vulnerable_range_strings_dict: dict[str, set[str]] = {}  # tag_name: range strings
    for action in topic.actions:
        if not action.ext or not (vulnerable_versions := action.ext.get("vulnerable_versions")):
            continue
        for tag_name, vulnerable_range_strings in vulnerable_versions.items():
            if (tmp_str_set := vulnerable_range_strings_dict.get(tag_name)) is None:
                tmp_str_set = set()
                vulnerable_range_strings_dict[tag_name] = tmp_str_set
            for vulnerable_range_string in vulnerable_range_strings:
                tmp_str_set |= set(vulnerable_range_string.split("||"))
    vulnerables_dict: dict[str, set[VulnerableRange]] = {}  # tag_name: VulnerableRanges
    for tag_name, vulnerable_range_strings in vulnerable_range_strings_dict.items():
        package_family = PackageFamily.from_tag_name(tag_name)
        if (tmp_obj_set := vulnerables_dict.get(tag_name)) is None:
            tmp_obj_set = set()
            vulnerables_dict[tag_name] = tmp_obj_set
        for vulnerable_range_string in vulnerable_range_strings:
            try:
                tmp_obj_set.add(
                    VulnerableRange.from_string(package_family, vulnerable_range_string)
                )
            except ValueError:
                pass  # ignore unexpected range strings

    # check and fix for each dependencies related to the topic
    created_ticket_ids: list[str] = []
    for dependency in topic.dependencies_via_tag:
        tag = dependency.tag
        try:
            dependency_version = gen_version_instance(
                PackageFamily.from_tag_name(tag.tag_name), dependency.version
            )
        except ValueError:
            dependency_version = None

        tmp_threats = command.search_threats(db, None, dependency.dependency_id, topic.topic_id)
        current_threat = tmp_threats[0] if tmp_threats else None

        if dependency_version:
            # collect vulnerables for this tag
            vulnerables_to_check = vulnerables_dict.get(tag.tag_name, set())
            if tag.parent_id and tag.parent_id != tag.tag_id:
                vulnerables_to_check |= vulnerables_dict.get(tag.parent_name, set())

            # detect how should be
            need_ticket = False
            if not vulnerables_to_check:
                # topic is matched with this dependency on the tag, but have no actionable info
                need_ticket = False
            else:
                for vulnerable in vulnerables_to_check:
                    try:
                        if vulnerable.detect_matched({dependency_version}):
                            # vulnerable and actionable
                            need_ticket = True
                            break
                    except ValueError:
                        pass
                        # continue to find out actionable or not
        else:
            # dependency version is not comparable
            need_ticket = False

        # fix ticket
        if current_threat:
            threat = current_threat
        else:
            threat = models.Threat(dependency_id=dependency.dependency_id, topic_id=topic.topic_id)
            persistence.create_threat(db, threat)
        if need_ticket:
            if not threat.ticket:
                ticket = create_ticket_internal(db, threat, now=now)
                created_ticket_ids.append(ticket.ticket_id)
        elif threat.ticket:
            persistence.delete_ticket(db, threat.ticket)

        db.flush()
    return created_ticket_ids


def fix_threats_for_dependency(db: Session, dependency: models.Dependency):
    now = datetime.now()
    tag = dependency.tag
    package_family = PackageFamily.from_tag_name(tag.tag_name)
    try:
        dependency_version = gen_version_instance(package_family, dependency.version)
    except ValueError:
        # dependency.version is not comparable
        dependency_version = None

    if dependency_version:
        # collect TopicActions
        topic_actions: list[models.TopicAction] = []
        for topic in tag.topics:
            topic_actions.extend(topic.actions)

        # collect VulnerableRanges for each topics from TopicAction
        vulnerable_range_strings_dict: dict[str, set[str]] = {}  # topic_id: range strings
        for action in topic_actions:
            if not action.ext or not (vulnerable_versions := action.ext.get("vulnerable_versions")):
                continue
            for tag_name, vulnerable_range_strings in vulnerable_versions.items():
                if tag_name not in {tag.tag_name, tag.parent_name}:
                    continue
                if (tmp_str_set := vulnerable_range_strings_dict.get(action.topic_id)) is None:
                    tmp_str_set = set()
                    vulnerable_range_strings_dict[action.topic_id] = tmp_str_set
                for vulnerable_range_string in vulnerable_range_strings:
                    tmp_str_set |= set(vulnerable_range_string.split("||"))
        vulnerables_dict: dict[str, set[VulnerableRange]] = {}  # topic_id: VulnerableRanges
        for topic_id, vulnerable_range_strings in vulnerable_range_strings_dict.items():
            if (tmp_obj_set := vulnerables_dict.get(topic_id)) is None:
                tmp_obj_set = set()
                vulnerables_dict[topic_id] = tmp_obj_set
            for vulnerable_range_string in vulnerable_range_strings:
                try:
                    tmp_obj_set.add(
                        VulnerableRange.from_string(package_family, vulnerable_range_string)
                    )
                except ValueError:
                    pass  # ignore unexpected range strings

    # check and fix for each topics related to the dependency
    for topic_id in [topic.topic_id for topic in tag.topics]:
        tmp_threats = command.search_threats(db, None, dependency.dependency_id, topic_id)
        current_threat = tmp_threats[0] if tmp_threats else None

        if dependency_version:
            # get vulnerables for this topic
            vulnerables_to_check = vulnerables_dict.get(topic_id, set())

            # detect how should be
            need_ticket = False
            if not vulnerables_to_check:
                # topic is matched with the dependency on the tag, but have no actionable info
                need_ticket = False
            else:
                for vulnerable in vulnerables_to_check:
                    try:
                        if vulnerable.detect_matched({dependency_version}):
                            # vulnerable and actionable
                            need_ticket = True
                            break
                    except ValueError:
                        pass
                        # continue to find out actionable or not
        else:
            # dependency version is not comparable
            need_ticket = False

        # fix ticket
        if current_threat:
            threat = current_threat
        else:
            threat = models.Threat(dependency_id=dependency.dependency_id, topic_id=topic_id)
            persistence.create_threat(db, threat)
        if need_ticket:
            if not threat.ticket:
                create_ticket_internal(db, threat, now=now)
        elif threat.ticket:
            persistence.delete_ticket(db, threat.ticket)
