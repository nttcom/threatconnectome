from sqlalchemy.orm import Session

from app import command, models
from app.detector.package_family import PackageFamily
from app.detector.version import version_factory
from app.detector.vulnerable_range import VulnerableRange


def detect_vulnerability_by_affect(db: Session, affect: models.Affect) -> set[str]:
    matched_package_version_ids: set[str] = set()
    for package in command.get_related_packages_by_affect(db, affect):
        for package_version in package.package_versions:
            if check_matched_package_version_and_affect(package_version, affect):
                matched_package_version_ids.add(package_version.package_version_id)
    return matched_package_version_ids


def check_matched_package_version_and_affect(
    package_version: models.PackageVersion, affect: models.Affect
) -> bool:
    if package_version.package.ecosystem != affect.ecosystem:
        return False
    package = package_version.package
    if isinstance(package, models.OSPackage):
        if package_version.package.source_name is not None:
            comparison_name = package_version.package.source_name
        else:
            comparison_name = package_version.package.name

        if affect.affected_name != comparison_name:
            return False
    else:
        if affect.affected_name != package_version.package.name:
            return False

    package_family = PackageFamily.from_registry(package_version.package.ecosystem)
    try:
        dependency_version = version_factory.gen_version_instance(
            package_family, package_version.version
        )
    except ValueError:
        return False

    for affected_version in _get_affected_versions(affect):
        try:
            vulnerable_range = VulnerableRange.from_string(package_family, affected_version)
            if vulnerable_range.detect_matched({dependency_version}):
                return True
        except ValueError:
            pass  # ignore unexpected range strings
    return False


def _get_affected_versions(affect: models.Affect) -> list[str]:
    if len(affect.affected_versions) > 0:
        return affect.affected_versions
    if len(affect.fixed_versions) > 0:
        return _change_versions_from_fixed_to_affected(affect.fixed_versions)
    return []


def _change_versions_from_fixed_to_affected(fixed_versions: list[str]) -> list[str]:
    if len(fixed_versions) != 1 or "," in fixed_versions[0]:
        return []

    # guess vulnerable version only if we can
    fixed_version = fixed_versions[0]
    if fixed_version.startswith(">="):
        affected_version = fixed_version.replace(">=", "<", 1)
    elif fixed_version.startswith(">"):
        affected_version = fixed_version.replace(">", "<=", 1)
    elif fixed_version.startswith("~>="):
        affected_version = fixed_version.replace("~>=", "<", 1)
    elif fixed_version.startswith("~>"):
        affected_version = fixed_version.replace("~>", "<=", 1)
    else:
        affected_version = f"< {fixed_version}"
    return [affected_version]
