import { http, HttpResponse } from "msw";

import { VulnerabilityTable } from "./VulnerabilityTable.jsx";
import { mockVulnIdsUnsolved, createVulnerabilityTableHandlers } from "./mocks/mockData.js";

const pteamId = "pteam-abc-123";
const serviceId = "service-a";
const packageId = "pkg-uuid-456";

export default {
  title: "PackagePage/VulnerabilityTable",
  component: VulnerabilityTable,
  tags: ["autodocs"],
  argTypes: {
    relatedTicketStatus: {
      control: { type: "select", options: ["unsolved", "solved"] },
      description: "Filter tickets by status (unsolved or solved)",
    },
  },
  decorators: [
    (Story) => (
      <div style={{ padding: "20px" }}>
        <Story />
      </div>
    ),
  ],
};

// Create default handlers using the shared factory
const defaultHandlers = createVulnerabilityTableHandlers(pteamId, serviceId, packageId);

// === Basic States ===

export const Default = {
  args: {
    relatedTicketStatus: "unsolved",
  },
  parameters: {
    msw: {
      handlers: defaultHandlers,
    },
    router: {
      memoryRouterProps: {
        initialEntries: [`/packages/${packageId}?pteamId=${pteamId}&serviceId=${serviceId}`],
      },
      path: "/packages/:packageId",
      useRoutes: true,
    },
  },
};

export const EmptyState = {
  args: {
    relatedTicketStatus: "unsolved",
  },
  parameters: {
    msw: {
      handlers: [
        http.get("*/pteams/:pteamId/vuln_ids", () => {
          return HttpResponse.json({ vuln_ids: [] });
        }),
        http.get("*/pteams/:pteamId/ticket_counts", () => {
          return HttpResponse.json({
            ssvc_priority_count: {
              immediate: 0,
              out_of_cycle: 0,
              scheduled: 0,
              defer: 0,
            },
          });
        }),
        ...defaultHandlers,
      ],
    },
    router: {
      memoryRouterProps: {
        initialEntries: [`/packages/${packageId}?pteamId=${pteamId}&serviceId=${serviceId}`],
      },
      path: "/packages/:packageId",
      useRoutes: true,
    },
  },
};

export const LoadingState = {
  args: {
    relatedTicketStatus: "unsolved",
  },
  parameters: {
    msw: {
      handlers: [
        http.get("*/pteams/:pteamId", async () => {
          await new Promise((resolve) => setTimeout(resolve, 2000));
          return HttpResponse.json({
            pteam_id: pteamId,
            pteam_name: "Test PTeam",
            services: [
              {
                service_id: serviceId,
                service_name: "Service Alpha",
                service_safety_impact: "Medium",
              },
            ],
          });
        }),
        http.get("*/pteams/:pteamId/vuln_ids", async () => {
          await new Promise((resolve) => setTimeout(resolve, 2000));
          return HttpResponse.json(mockVulnIdsUnsolved);
        }),
        http.get("*/pteams/:pteamId/ticket_counts", async () => {
          await new Promise((resolve) => setTimeout(resolve, 2000));
          return HttpResponse.json({
            ssvc_priority_count: {
              immediate: 5,
              out_of_cycle: 8,
              scheduled: 10,
              defer: 3,
            },
          });
        }),
        ...defaultHandlers,
      ],
    },
    router: {
      memoryRouterProps: {
        initialEntries: [`/packages/${packageId}?pteamId=${pteamId}&serviceId=${serviceId}`],
      },
      path: "/packages/:packageId",
      useRoutes: true,
    },
  },
};

// === Data Variations ===

export const WithPagination = {
  args: {
    relatedTicketStatus: "unsolved",
  },
  parameters: {
    msw: {
      handlers: [
        http.get("*/pteams/:pteamId/vuln_ids", () => {
          const manyVulnIds = [
            ...mockVulnIdsUnsolved.vuln_ids,
            ...Array.from({ length: 15 }, (_, i) => `vuln-extra-${i}`),
          ];
          return HttpResponse.json({ vuln_ids: manyVulnIds });
        }),
        http.get("*/pteams/:pteamId/ticket_counts", () => {
          return HttpResponse.json({
            ssvc_priority_count: {
              immediate: 5,
              out_of_cycle: 8,
              scheduled: 10,
              defer: 3,
            },
          });
        }),
        ...defaultHandlers,
      ],
    },
    router: {
      memoryRouterProps: {
        initialEntries: [`/packages/${packageId}?pteamId=${pteamId}&serviceId=${serviceId}`],
      },
      path: "/packages/:packageId",
      useRoutes: true,
    },
  },
};

// === Error States ===

export const ErrorVulnIdsList = {
  args: {
    relatedTicketStatus: "unsolved",
  },
  parameters: {
    msw: {
      handlers: [
        http.get("*/pteams/:pteamId/vuln_ids", () => {
          return HttpResponse.json({ detail: "Internal Server Error" }, { status: 500 });
        }),
        ...defaultHandlers,
      ],
    },
    router: {
      memoryRouterProps: {
        initialEntries: [`/packages/${packageId}?pteamId=${pteamId}&serviceId=${serviceId}`],
      },
      path: "/packages/:packageId",
      useRoutes: true,
    },
  },
};

export const ErrorVulnData = {
  args: {
    relatedTicketStatus: "unsolved",
  },
  parameters: {
    msw: {
      handlers: [
        http.get("*/vulns/:vulnId", () => {
          return HttpResponse.json({ detail: "Vulnerability not found" }, { status: 404 });
        }),
        ...defaultHandlers,
      ],
    },
    router: {
      memoryRouterProps: {
        initialEntries: [`/packages/${packageId}?pteamId=${pteamId}&serviceId=${serviceId}`],
      },
      path: "/packages/:packageId",
      useRoutes: true,
    },
  },
};

export const ErrorDependencies = {
  args: {
    relatedTicketStatus: "unsolved",
  },
  parameters: {
    msw: {
      handlers: [
        ...defaultHandlers.filter((handler) => !handler.info.path.includes("/dependencies")),
        http.get("*/pteams/:pteamId/dependencies", () => {
          return HttpResponse.json({ detail: "Failed to fetch dependencies" }, { status: 500 });
        }),
      ],
    },
    router: {
      memoryRouterProps: {
        initialEntries: [`/packages/${packageId}?pteamId=${pteamId}&serviceId=${serviceId}`],
      },
      path: "/packages/:packageId",
      useRoutes: true,
    },
  },
};

export const ErrorTickets = {
  args: {
    relatedTicketStatus: "unsolved",
  },
  parameters: {
    msw: {
      handlers: [
        http.get("*/pteams/:pteamId/tickets", () => {
          return HttpResponse.json({ detail: "Failed to fetch tickets" }, { status: 500 });
        }),
        ...defaultHandlers,
      ],
    },
    router: {
      memoryRouterProps: {
        initialEntries: [`/packages/${packageId}?pteamId=${pteamId}&serviceId=${serviceId}`],
      },
      path: "/packages/:packageId",
      useRoutes: true,
    },
  },
};

export const ErrorNoDependencies = {
  args: {
    relatedTicketStatus: "unsolved",
  },
  parameters: {
    msw: {
      handlers: [
        ...defaultHandlers.filter((handler) => !handler.info.path.includes("/dependencies")),
        http.get("*/pteams/:pteamId/dependencies", () => {
          return HttpResponse.json([]);
        }),
      ],
    },
    router: {
      memoryRouterProps: {
        initialEntries: [`/packages/${packageId}?pteamId=${pteamId}&serviceId=${serviceId}`],
      },
      path: "/packages/:packageId",
      useRoutes: true,
    },
  },
};
